struct @VMContext {
  stack: [10] i32;  // The VM stack for storing operands and results
  prog: [10] i32;   // Memory area for storing the VM bytecode program
  sp: i32;          // Stack Pointer (points to the next free slot in 'stack')
  pc: i32;          // Program Counter (points to the next instruction in 'prog')
}

fun @main() : i32 {
  // =========================================================================================
  // SymIR Stack-based Virtual Machine (Symbolic Synthesis Version)
  //
  // This program implements a small virtual machine that operates on an integer stack.
  // It demonstrates:
  // 1. Concrete Execution: Running a sequence of opcodes to transform data.
  // 2. Program Synthesis: Finding a missing opcode to reach a target stack state.
  //
  // VM Opcodes:
  //   0: HALT
  //   1: PUSH <val>  (Pushes next byte onto stack)
  //   2: ADD         (Pop A, Pop B, Push A + B)
  //   3: SUB         (Pop A, Pop B, Push B - A)
  //   4: DUP         (Pop A, Push A, Push A)
  //
  // Configuration:
  // - Stack Size: 10
  // - Program Size: 10
  //
  // Interpret:
  //   ./symiri --sym %?missing_op=2 ./examples/stack_vm.sir
  //
  // Compile:
  //   ./symirc -o stack_vm.c ./examples/stack_vm.sir
  //
  // Solve (Synthesize the missing ADD instruction):
  //   ./symirsolve --path $(cat ./examples/stack_vm_path.txt) -o stack_vm.sir ./examples/stack_vm.sir
  // =========================================================================================

  // --- 0. Symbolic Instruction ---
  // We have a "hole" in our bytecode. What operation turns [10, 20] into 30?
  sym %?missing_op : value i32 in {2, 3}; // 2=ADD, 3=SUB. Expected: 2 (ADD)

  // --- 1. VM Memory & Registers ---
  let mut %vm: @VMContext = 0;

  // Temporaries
  let mut %opcode: i32 = 0;
  let mut %a: i32 = 0;
  let mut %b: i32 = 0;
  let mut %res: i32 = 0;
  let mut %idx_tmp: i32 = 0;

  // Constants
  let %OP_HALT: i32 = 0;
  let %OP_PUSH: i32 = 1;
  let %OP_ADD:  i32 = 2;
  let %OP_SUB:  i32 = 3;
  let %OP_DUP:  i32 = 4;

^entry:
  // Initialize VM
  %vm.sp = 0;
  %vm.pc = 0;

  // --- 2. Load Program ---
  // prog = [ PUSH 10, PUSH 20, <MISSING>, HALT ]

  // PUSH 10
  %vm.prog[0] = 1;
  %vm.prog[1] = 10;

  // PUSH 20
  %vm.prog[2] = 1;
  %vm.prog[3] = 20;

  // Symbolic Opcode (Index 4)
  %vm.prog[4] = %?missing_op;

  // HALT
  %vm.prog[5] = 0;

  br ^dispatch;

  // --- 3. Execution Loop ---
^dispatch:
  %idx_tmp = %vm.pc;
  br %idx_tmp >= 10, ^exit, ^fetch;

^fetch:
  %idx_tmp = %vm.pc;
  %opcode = %vm.prog[%idx_tmp];
  %vm.pc = %idx_tmp + 1;

  br %opcode == %OP_HALT, ^exit, ^decode_push;

^decode_push:
  br %opcode == %OP_PUSH, ^do_push, ^decode_add;

^decode_add:
  br %opcode == %OP_ADD, ^do_add, ^decode_sub;

^decode_sub:
  br %opcode == %OP_SUB, ^do_sub, ^decode_dup;

^decode_dup:
  br %opcode == %OP_DUP, ^do_dup, ^dispatch; // Skip unknown

// --- 4. Opcode Implementations ---

^do_push:
  %idx_tmp = %vm.pc;
  %res = %vm.prog[%idx_tmp];
  %vm.pc = %idx_tmp + 1;

  %idx_tmp = %vm.sp;
  %vm.stack[%idx_tmp] = %res;
  %vm.sp = %idx_tmp + 1;
  br ^dispatch;

^do_add:
  %idx_tmp = %vm.sp;
  %idx_tmp = %idx_tmp - 1;
  %a = %vm.stack[%idx_tmp];

  %idx_tmp = %idx_tmp - 1;
  %b = %vm.stack[%idx_tmp];

  %res = %a + %b;
  %vm.stack[%idx_tmp] = %res;
  %vm.sp = %idx_tmp + 1;
  br ^dispatch;

^do_sub:
  %idx_tmp = %vm.sp;
  %idx_tmp = %idx_tmp - 1;
  %a = %vm.stack[%idx_tmp];

  %idx_tmp = %idx_tmp - 1;
  %b = %vm.stack[%idx_tmp];

  %res = %b - %a;
  %vm.stack[%idx_tmp] = %res;
  %vm.sp = %idx_tmp + 1;
  br ^dispatch;

^do_dup:
  %idx_tmp = %vm.sp;
  %idx_tmp = %idx_tmp - 1;
  %a = %vm.stack[%idx_tmp];

  %vm.stack[%idx_tmp] = %a;
  %idx_tmp = %idx_tmp + 1;
  %vm.stack[%idx_tmp] = %a;
  %vm.sp = %idx_tmp + 1;
  br ^dispatch;

^exit:
  // Return the top of the stack
  %idx_tmp = %vm.sp;
  %idx_tmp = %idx_tmp - 1;
  %res = %vm.stack[%idx_tmp];

  // =========================================================================================
  // [REQUIREMENT]
  // We want the final result on the stack to be 30.
  // Given PUSH 10, PUSH 20, the missing op must be ADD (2).
  // =========================================================================================
  require %res == 30, "Stack top must be 30";

  ret %res;
}
