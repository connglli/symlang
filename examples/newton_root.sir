// EXPECT: PASS
struct @NewtonContext {
  x: f64;     // The current estimate of the root
  fx: f64;    // The value of the function f(x) at the current estimate
  dfx: f64;   // The derivative f'(x) at the current estimate
  step: f64;  // The calculated adjustment step: f(x) / f'(x)
  diff: f64;  // The error between the current estimate and the known target
}

fun @main() : f64 {
  // =========================================================================================
  // SymIR Newton-Raphson Root Finder (Floating Point Version)
  //
  // This program implements Newton's method to find the root of f(x) = x^2 - 2.
  //   Formula: x_{n+1} = x_n - f(x_n) / f'(x_n)
  //   For f(x) = x^2 - 2, f'(x) = 2x.
  //
  // It demonstrates:
  // 1. Floating-point Support: Using f64 types and literals.
  // 2. Numerical Synthesis: Finding an initial guess that converges quickly.
  //
  // Interpret (with guess 2.0):
  //   ./symiri --sym %?start_x=2.0 ./examples/newton_root.sir
  //
  // Compile:
  //   ./symirc -o newton_root.c ./examples/newton_root.sir
  //
  // Solve (Synthesize a valid initial guess):
  //   ./symirsolve --path $(cat ./examples/newton_root_path.txt) -o newton_root.sir ./examples/newton_root.sir
  // =========================================================================================

  // --- 0. Symbolic Initial Guess ---
  sym %?start_x : value f64;

  // --- 1. State Variables ---
  let mut %ctx: @NewtonContext = 0.0;

  // Locals for coefficients (v0 restricts Coef to simple LocalId/SymId)
  let mut %x_v: f64 = 0.0;
  let mut %fx_v: f64 = 0.0;
  let mut %dfx_v: f64 = 0.0;
  let mut %diff_v: f64 = 0.0;
  let mut %ret_val: f64 = 0.0;

  // Constants
  let %TWO: f64 = 2.0;
  let %TARGET: f64 = 1.41421356237;

^entry:
  %ctx.x = %?start_x;

  // Constraint: start_x must be reasonable (e.g., >= 1.0)
  %x_v = %ctx.x;
  assume %x_v >= 1.0;
  br ^iter1;

  // --- Iteration 1 ---
^iter1:
  %x_v = %ctx.x;
  %ctx.fx = %x_v * %ctx.x - %TWO;

  %x_v = %ctx.x;
  %ctx.dfx = %TWO * %x_v;

  %fx_v = %ctx.fx;
  %ctx.step = %fx_v / %ctx.dfx;

  %x_v = %ctx.x;
  %ctx.x = %x_v - %ctx.step;
  br ^iter2;

  // --- Iteration 2 ---
^iter2:
  %x_v = %ctx.x;
  %ctx.fx = %x_v * %ctx.x - %TWO;

  %x_v = %ctx.x;
  %ctx.dfx = %TWO * %x_v;

  %fx_v = %ctx.fx;
  %ctx.step = %fx_v / %ctx.dfx;

  %x_v = %ctx.x;
  %ctx.x = %x_v - %ctx.step;
  br ^iter3;

  // --- Iteration 3 ---
^iter3:
  %x_v = %ctx.x;
  %ctx.fx = %x_v * %ctx.x - %TWO;

  %x_v = %ctx.x;
  %ctx.dfx = %TWO * %x_v;

  %fx_v = %ctx.fx;
  %ctx.step = %fx_v / %ctx.dfx;

  %x_v = %ctx.x;
  %ctx.x = %x_v - %ctx.step;
  br ^exit;

^exit:
  // --- Check Convergence ---
  %x_v = %ctx.x;
  %ctx.diff = %x_v - %TARGET;

  %diff_v = %ctx.diff;
  // Absolute difference (relaxed to 1e-5 for 3 iterations)
  require %diff_v < 0.00001, "Must converge to sqrt(2)";
  require %diff_v > -0.00001, "Must converge to sqrt(2)";

  %ret_val = %ctx.x;
  ret %ret_val;
}
