struct @FeistelContext {
  l: i8;      // Left half of the block
  r: i8;      // Right half of the block
  k: i8;      // The master key
  round: i32; // Round counter
}

fun @main() : i32 {
  // =========================================================================================
  // SymIR Iterative Feistel Cipher (Loop-based Bitwise Logic)
  //
  // This program implements a 4-round Feistel network using a loop.
  // It demonstrates:
  // 1. Loops: Using a round counter and a back-edge to repeat encryption rounds.
  // 2. Bitwise Logic: XOR (^), bitwise AND (&) for masking.
  // 3. Symbolic Cryptanalysis: Finding a key that satisfies a plaintext-ciphertext pair.
  //
  // Configuration:
  // - Rounds: 4
  // - Plaintext: L=10 (0xA), R=11 (0xB)
  // - Target: L=11, R=4
  //
  // Interpret:
  //   ./symiri --sym %?key=5 ./examples/feistel_cipher.sir
  //
  // Compile:
  //   ./symirc -o feistel_cipher.c ./examples/feistel_cipher.sir
  //
  // Solve:
  //   ./symirsolve --path $(cat ./examples/feistel_cipher_path.txt) -o feistel_cipher.sir ./examples/feistel_cipher.sir
  // =========================================================================================

  // --- 0. Symbolic Key ---
  sym %?key : value i8 in [0, 15];

  // --- 1. State Variables ---
  let mut %ctx: @FeistelContext = 0;

  // Locals for logic
  let mut %l_old: i8 = 0;
  let mut %r_old: i8 = 0;
  let mut %f_out: i8 = 0;
  let mut %curr_round: i32 = 0;
  let mut %res: i32 = 0;

  // Constants
  let %ONE: i32 = 1;
  let %ROUNDS: i32 = 4;
  let %MASK: i8 = 15; // 0xF

^entry:
  // Initialize Context
  %ctx.l = 10;
  %ctx.r = 11;
  %ctx.k = %?key;
  %ctx.round = 0;
  br ^round_cond;

^round_cond:
  %curr_round = %ctx.round;
  br %curr_round < %ROUNDS, ^round_body, ^exit;

^round_body:
  // Round Function: F(R, K) = (R ^ K) & 0xF
  %r_old = %ctx.r;
  %f_out = %r_old ^ %ctx.k;
  %f_out = %f_out & %MASK;

  // Feistel Step:
  %l_old = %ctx.l;
  %ctx.l = %r_old;
  %ctx.r = %l_old ^ %f_out;

  // Increment Round
  %ctx.round = %curr_round + %ONE;
  br ^round_cond;

^exit:
  // =========================================================================================
  // [REQUIREMENT]
  // Target: L=11, R=4 (Achieved by key=5 after 4 rounds)
  // =========================================================================================
  %l_old = %ctx.l;
  %r_old = %ctx.r;
  require %l_old == 11, "Left half target";
  require %r_old == 4, "Right half target";

  %res = %l_old as i32;
  ret %res;
}
