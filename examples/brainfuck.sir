fun @main() : i32 {
  // =========================================================================================
  // SymIR Brainfuck Interpreter
  //
  // This program implements a simple Brainfuck interpreter.
  // It executes a hardcoded Brainfuck program stored in the %code array.
  //
  // Configuration:
  // - Tape Size: Defined by the size of %tape (default 100) and %TAPE_LIMIT.
  // - Code Size: Defined by the size of %code (default 100) and %CODE_LIMIT.
  // - Output Size: Defined by the size of %output (default 100).
  //
  // To change the program:
  // 1. Modify the array sizes below if your program is larger than 100 bytes.
  // 2. Update %CODE_LIMIT and %TAPE_LIMIT constants to match.
  // 3. Edit the "^entry" block to load your Brainfuck bytecode into %code.
  // =========================================================================================

  // --- 1. Memory Configuration ---
  // [USER-CONFIG] Change array sizes here if needed.
  let mut %tape:   [100] i8 = 0;
  let mut %code:   [100] i8 = 0;
  let mut %output: [100] i8 = 0;

  // --- 2. State Variables ---
  // Pointers and Indices
  let mut %dp:      i32 = 0; // Data Pointer
  let mut %ip:      i32 = 0; // Instruction Pointer
  let mut %out_idx: i32 = 0; // Output Buffer Index

  // Temporary Variables for Logic
  let mut %instr:    i8 = 0;
  let mut %byte_tmp: i8 = 0;
  let mut %ret_val:  i32 = 0;

  // Depth calculation temps for loop scanning
  let mut %d_plus:  i32 = 0;
  let mut %d_minus: i32 = 0;

  // --- 3. Constants ---
  // [USER-CONFIG] Update limits to match array sizes above.
  let %CODE_LIMIT: i32 = 100;
  // let %TAPE_LIMIT: i32 = 100; // Unused in this simple version (we rely on UB for out-of-bounds)

  let %ONE: i32 = 1;
  // let %ZERO: i32 = 0; // Unused

  // --- 4. Brainfuck Command Set ---
  let %CMD_INC_PTR:    i8 = 62; // >
  let %CMD_DEC_PTR:    i8 = 60; // <
  let %CMD_INC_VAL:    i8 = 43; // +
  let %CMD_DEC_VAL:    i8 = 45; // -
  let %CMD_OUTPUT:     i8 = 46; // .
  // let %CMD_INPUT:      i8 = 44; // , (Implemented as no-op, commented out to avoid unused warning)
  let %CMD_LOOP_START: i8 = 91; // [
  let %CMD_LOOP_END:   i8 = 93; // ]

  // Bracket scanning depth counter
  let mut %depth: i32 = 0;

^entry:
  // =========================================================================================
  // [USER-CODE] Load Brainfuck Program Here
  // Current Program: ++++++++[>++++++++<-]>+. (Prints 'A')
  // =========================================================================================

  // 0-7: ++++++++ (Set cell #0 to 8)
  %code[0] = 43; %code[1] = 43; %code[2] = 43; %code[3] = 43;
  %code[4] = 43; %code[5] = 43; %code[6] = 43; %code[7] = 43;

  // 8: [ (Start loop)
  %code[8] = 91;

  // 9: > (Move to cell #1)
  %code[9] = 62;

  // 10-17: ++++++++ (Add 8 to cell #1)
  %code[10] = 43; %code[11] = 43; %code[12] = 43; %code[13] = 43;
  %code[14] = 43; %code[15] = 43; %code[16] = 43; %code[17] = 43;

  // 18: < (Move back to cell #0)
  %code[18] = 60;

  // 19: - (Decrement cell #0)
  %code[19] = 45;

  // 20: ] (End loop - repeat until cell #0 is 0)
  // Loop logic: cell #1 += 8 for each iteration. Total cell #1 = 8 * 8 = 64.
  %code[20] = 93;

  // 21: > (Move to cell #1, which is now 64)
  %code[21] = 62;

  // 22: + (Increment cell #1 to 65)
  %code[22] = 43;

  // 23: . (Output cell #1 - ASCII 'A')
  %code[23] = 46;

  // 24: Terminate (0)
  %code[24] = 0;

  // End of Program Loading
  br ^dispatch;

  // --- Main Dispatch Loop ---
^dispatch:
  // Check code bounds
  br %ip >= %CODE_LIMIT, ^exit, ^fetch;

^fetch:
  %instr = %code[%ip];
  // 0 terminates execution
  br %instr == 0, ^exit, ^decode_inc_ptr;

// --- Instruction Decoding ---
^decode_inc_ptr:
  br %instr == %CMD_INC_PTR, ^do_inc_ptr, ^decode_dec_ptr;

^decode_dec_ptr:
  br %instr == %CMD_DEC_PTR, ^do_dec_ptr, ^decode_inc_val;

^decode_inc_val:
  br %instr == %CMD_INC_VAL, ^do_inc_val, ^decode_dec_val;

^decode_dec_val:
  br %instr == %CMD_DEC_VAL, ^do_dec_val, ^decode_output;

^decode_output:
  br %instr == %CMD_OUTPUT, ^do_output, ^decode_loop_start;

^decode_loop_start:
  br %instr == %CMD_LOOP_START, ^do_loop_start, ^decode_loop_end;

^decode_loop_end:
  br %instr == %CMD_LOOP_END, ^do_loop_end, ^next_instr; // Skip unknown/comments

// --- Command Execution ---

^do_inc_ptr: // >
  %dp = %dp + %ONE;
  br ^next_instr;

^do_dec_ptr: // <
  %dp = %dp - %ONE;
  br ^next_instr;

^do_inc_val: // +
  %tape[%dp] = %tape[%dp] + 1;
  br ^next_instr;

^do_dec_val: // -
  %tape[%dp] = %tape[%dp] - 1;
  br ^next_instr;

^do_output: // .
  // Hardcoded output limit check (100)
  br %out_idx < 100, ^write_out, ^next_instr;
^write_out:
  %output[%out_idx] = %tape[%dp];
  %out_idx = %out_idx + %ONE;
  br ^next_instr;

^do_loop_start: // [
  %byte_tmp = %tape[%dp];
  // If current tape value is 0, jump to matching ]
  br %byte_tmp == 0, ^scan_fwd_init, ^next_instr;

^do_loop_end: // ]
  %byte_tmp = %tape[%dp];
  // If current tape value is nonzero, jump back to matching [
  br %byte_tmp != 0, ^scan_bwd_init, ^next_instr;

// --- Loop Skipping Logic (Forward Scan [ -> ]) ---
^scan_fwd_init:
  %depth = 1;
  br ^scan_fwd_step;

^scan_fwd_step:
  %ip = %ip + %ONE;
  br %ip >= %CODE_LIMIT, ^exit, ^scan_fwd_check;

^scan_fwd_check:
  %byte_tmp = %code[%ip];

  // depth++ if we see another [
  %d_plus = %depth + 1;
  %depth = select %byte_tmp == %CMD_LOOP_START, %d_plus, %depth;

  // depth-- if we see a ]
  %d_minus = %depth - 1;
  %depth = select %byte_tmp == %CMD_LOOP_END, %d_minus, %depth;

  // If depth is 0, we found the matching ]
  br %depth == 0, ^next_instr, ^scan_fwd_step;

// --- Loop Rewinding Logic (Backward Scan ] -> [) ---
^scan_bwd_init:
  %depth = 1;
  br ^scan_bwd_step;

^scan_bwd_step:
  %ip = %ip - %ONE;
  br %ip < 0, ^exit, ^scan_bwd_check;

^scan_bwd_check:
  %byte_tmp = %code[%ip];

  // depth++ if we see a ] (since we are going backwards)
  %d_plus = %depth + 1;
  %depth = select %byte_tmp == %CMD_LOOP_END, %d_plus, %depth;

  // depth-- if we see a [
  %d_minus = %depth - 1;
  %depth = select %byte_tmp == %CMD_LOOP_START, %d_minus, %depth;

  // If depth is 0, we found the matching [.
  br %depth == 0, ^scan_bwd_done, ^scan_bwd_step;

^scan_bwd_done:
  // We are at [. We want to execute it again (re-evaluate condition).
  // Jump directly to dispatch to avoid incrementing %ip in ^next_instr
  br ^dispatch;


^next_instr:
  %ip = %ip + %ONE;
  br ^dispatch;

^exit:
  // Return the first byte of output (helpful for testing)
  %byte_tmp = %output[0];
  %ret_val = %byte_tmp as i32;
  ret %ret_val;
}
