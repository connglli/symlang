// EXPECT: PASS
// SOLVER_ARGS: --main @main --path '^entry'

// Matrix A (Symbolic) * B (Identity) == C (Target)
// implies A == C.

struct @Matrix { data: [2][2]i32; }

fun @main() : i32 {
  sym %?a00 : value i32 in [0, 100];
  sym %?a01 : value i32 in [0, 100];
  sym %?a10 : value i32 in [0, 100];
  sym %?a11 : value i32 in [0, 100];

  let mut %A: @Matrix;
  let mut %B: @Matrix;
  let mut %C: @Matrix;
  let mut %t1: i32 = 0;
  let mut %t2: i32 = 0;
  let mut %v1: i32 = 0;
  let mut %v2: i32 = 0;
  let mut %v3: i32 = 0;
  let mut %v4: i32 = 0;

^entry:
  %A.data[0][0] = %?a00;
  %A.data[0][1] = %?a01;
  %A.data[1][0] = %?a10;
  %A.data[1][1] = %?a11;

  %B.data[0][0] = 1; %B.data[0][1] = 0;
  %B.data[1][0] = 0; %B.data[1][1] = 1;

  // Unrolled 2x2 multiplication
  // C[0][0] = A[0][0]*B[0][0] + A[0][1]*B[1][0]
  %v1 = %A.data[0][0]; %v2 = %B.data[0][0];
  %t1 = %v1 * %v2;
  %v3 = %A.data[0][1]; %v4 = %B.data[1][0];
  %t2 = %v3 * %v4;
  %C.data[0][0] = %t1 + %t2;

  // C[0][1] = A[0][0]*B[0][1] + A[0][1]*B[1][1]
  %v1 = %A.data[0][0]; %v2 = %B.data[0][1];
  %t1 = %v1 * %v2;
  %v3 = %A.data[0][1]; %v4 = %B.data[1][1];
  %t2 = %v3 * %v4;
  %C.data[0][1] = %t1 + %t2;

  // C[1][0] = A[1][0]*B[0][0] + A[1][1]*B[1][0]
  %v1 = %A.data[1][0]; %v2 = %B.data[0][0];
  %t1 = %v1 * %v2;
  %v3 = %A.data[1][1]; %v4 = %B.data[1][0];
  %t2 = %v3 * %v4;
  %C.data[1][0] = %t1 + %t2;

  // C[1][1] = A[1][0]*B[0][1] + A[1][1]*B[1][1]
  %v1 = %A.data[1][0]; %v2 = %B.data[0][1];
  %t1 = %v1 * %v2;
  %v3 = %A.data[1][1]; %v4 = %B.data[1][1];
  %t2 = %v3 * %v4;
  %C.data[1][1] = %t1 + %t2;

  // Requirement: C == {{10, 20}, {30, 40}}
  require %C.data[0][0] == 10, "C[0][0] must be 10";
  require %C.data[0][1] == 20, "C[0][1] must be 20";
  require %C.data[1][0] == 30, "C[1][0] must be 30";
  require %C.data[1][1] == 40, "C[1][1] must be 40";

  ret 0;
}
