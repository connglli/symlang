// EXPECT: PASS
// SOLVER_ARGS: --main @main --path '^entry,^target'
// INTERP_ARGS: --main @main --sym %?val=50 --sym %?idx=0
// COMPILER_ARGS: --main @main --sym %?val=50 --sym %?idx=0

struct @Point { x: i32; y: i32; }

fun @main() : i32 {
  sym %?idx : value i32 in [0, 1];
  sym %?val : value i32 in [0, 100];
  let mut %arr: [2] @Point;

^entry:
  %arr[0].x = 10;
  %arr[0].y = 11;
  %arr[1].x = 20;
  %arr[1].y = 21;
  br ^target;

^target:
  %arr[%?idx].x = %?val;

  // If ?idx == 0, then arr[0].x == ?val, and arr[1].x should be preserved (20)
  // We want to find a solution where ?idx == 0 and ?val == 50
  assume %?idx == 0;
  assume %?val == 50;

  require %arr[0].x == 50, "arr[0].x must be 50 after symbolic write";
  require %arr[1].x == 20, "arr[1].x must be preserved";
  require %arr[0].y == 11, "arr[0].y must be preserved";
  require %arr[1].y == 21, "arr[1].y must be preserved";

  ret 0;
}
