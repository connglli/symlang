// EXPECT: PASS
// SOLVER_ARGS: --path ^entry,^init,^loop_cond,^loop_body,^check,^next,^loop_cond,^loop_body,^next,^loop_cond,^exit
// SKIP: COMPILER
// SKIP: INTERPRETER

struct @Queen {
    row: i32;
    col: i32;
    id: [2] i32;
}

struct @BoardConfig {
    queens: [2] @Queen;
    root: @Queen;
    meta: [2] i32;
}

struct @ProblemAnswer {
    configs: [2] @BoardConfig;
    best: @BoardConfig;
    status: [4] i32;
}

fun @main(): i32 {
    sym %?r0: value i32 in [0, 3];
    sym %?c0: value i32 in [0, 3];
    sym %?r1: value i32 in [0, 3];
    sym %?c1: value i32 in [0, 3];

    let mut %ans: @ProblemAnswer = {
        {
            { {{0,0,{0,0}}, {0,0,{0,0}}}, {0,0,{0,0}}, {0,0} },
            { {{0,0,{0,0}}, {0,0,{0,0}}}, {0,0,{0,0}}, {0,0} }
        },
        { {{0,0,{0,0}}, {0,0,{0,0}}}, {0,0,{0,0}}, {0,0} },
        {0, 0, 0, 0}
    };
    let mut %i: i32 = 0;
    let %one: i32 = 1;
    let %limit: i32 = 2;

^entry:
    %ans.configs[0].queens[0].row = %?r0;
    %ans.configs[0].queens[0].col = %?c0;
    %ans.configs[0].queens[1].row = %?r1;
    %ans.configs[0].queens[1].col = %?c1;
    br ^init;

^init:
    %i = 0;
    br ^loop_cond;

^loop_cond:
    br %i < %limit, ^loop_body, ^exit;

^loop_body:
    br %i == 0, ^check, ^next;

^check:
    // Queens must be in different rows and different columns
    require %ans.configs[0].queens[0].row != %ans.configs[0].queens[1].row, "diff row";
    require %ans.configs[0].queens[0].col != %ans.configs[0].queens[1].col, "diff col";
    br ^next;

^next:
    %i = %i + %one;
    br ^loop_cond;

^exit:
    ret 0;
}
