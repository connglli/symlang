// EXPECT: PASS
// SOLVER_ARGS: --path ^entry,^init,^loop_cond,^loop_body,^visit,^next,^exit

struct @NodeState {
    dist: i32;
    color: i32;
    path: [2] i32;
}

struct @GraphLayer {
    nodes: [2] @NodeState;
    meta: @NodeState;
    adj_matrix: [4] i32;
}

struct @ProblemAnswer {
    layers: [2] @GraphLayer;
    header: @GraphLayer;
    queue: [4] i32;
}

fun @main(): i32 {
    let mut %ans: @ProblemAnswer = {
        {
            {
                { {0, 1, {0, 0}}, {1, 0, {1, 0}} },
                {0, 0, {0, 0}},
                {0, 1, 1, 0}
            },
            {
                { {2, 1, {0, 1}}, {3, 0, {1, 1}} },
                {1, 1, {1, 1}},
                {1, 0, 0, 1}
            }
        },
        {
            { {0, 0, {0, 0}}, {0, 0, {0, 0}} },
            {0, 0, {0, 0}},
            {0, 0, 0, 0}
        },
        {0, 1, 2, 3}
    };
    let mut %i: i32 = 0;
    let mut %curr: i32 = 0;
    let %one: i32 = 1;
    let %limit: i32 = 4;

^entry:
    br ^init;

^init:
    %i = 0;
    br ^loop_cond;

^loop_cond:
    br %i < %limit, ^loop_body, ^exit;

^loop_body:
    %curr = %ans.queue[%i];
    br %curr == 0, ^visit, ^next;

^visit:
    %ans.layers[0].nodes[0].color = 2; // Visited
    br ^next;

^next:
    %i = %i + %one;
    br ^loop_cond;

^exit:
    ret 0;
}
