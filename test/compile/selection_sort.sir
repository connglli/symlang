// EXPECT: PASS
struct @Range { start: i32; end: i32; }
struct @MinTracker { idx: i32; val: i32; }

fun @main() : i32 {
  let mut %data: [5] i32 = {3, 1, 4, 1, 5};
  let mut %meta: @Range = {0, 5};
  let mut %tracker: @MinTracker = {0, 0};
  let mut %i: i32 = 0;
  let mut %j: i32 = 0;
  let mut %v: i32 = 0;
  let mut %tmp: i32 = 0;
  let mut %curr_i: i32 = 0;
  let mut %curr_j: i32 = 0;
  let mut %curr_min_idx: i32 = 0;
  let %one: i32 = 1;

^entry:
  br ^outer_loop;

^outer_loop:
  br %i < 4, ^inner_init, ^exit;

^inner_init:
  %tracker.idx = %i;
  %curr_i = %i;
  %tracker.val = %data[%curr_i];
  %j = %i + %one;
  br ^inner_loop;

^inner_loop:
  br %j < 5, ^compare, ^swap;

^compare:
  %curr_j = %j;
  %v = %data[%curr_j];
  br %v < %tracker.val, ^update_min, ^next_j;

^update_min:
  %tracker.idx = %j;
  %curr_j = %j;
  %tracker.val = %data[%curr_j];
  br ^next_j;

^next_j:
  %j = %j + %one;
  br ^inner_loop;

^swap:
  %curr_i = %i;
  %curr_min_idx = %tracker.idx;
  %tmp = %data[%curr_i];
  %data[%curr_i] = %data[%curr_min_idx];
  %data[%curr_min_idx] = %tmp;
  br ^outer_inc;

^outer_inc:
  %i = %i + %one;
  br ^outer_loop;

^exit:
  require %data[0] == 1, "sorted 0";
  require %data[1] == 1, "sorted 1";
  require %data[2] == 3, "sorted 2";
  ret 0;
}
