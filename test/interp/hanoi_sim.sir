// EXPECT: PASS
// ARGS: --sym %?n=3
fun @main() : i32 {
  sym %?n : value i32;
  let mut %stack: [100] i32 = 0;
  let mut %sp: i32 = 0;
  let mut %moves: i32 = 0;

  let mut %curr_n: i32 = 0;
  let mut %stage: i32 = 0;
  let mut %s: i32 = 0;
  let mut %d: i32 = 0;
  let mut %a: i32 = 0;

  let %c1: i32 = 1;

^entry:
  // Push initial call: hanoi(%?n, 1, 3, 2)
  %stack[%sp] = %?n; %sp = %sp + %c1;
  %stack[%sp] = 0; %sp = %sp + %c1;
  %stack[%sp] = 1; %sp = %sp + %c1;
  %stack[%sp] = 3; %sp = %sp + %c1;
  %stack[%sp] = 2; %sp = %sp + %c1;

  br ^while_loop;

^while_loop:
  br %sp > 0, ^pop, ^exit;

^pop:
  %sp = %sp - %c1; %a = %stack[%sp];
  %sp = %sp - %c1; %d = %stack[%sp];
  %sp = %sp - %c1; %s = %stack[%sp];
  %sp = %sp - %c1; %stage = %stack[%sp];
  %sp = %sp - %c1; %curr_n = %stack[%sp];

  br %curr_n == 0, ^while_loop, ^process;

^process:
  br %stage == 0, ^stage0, ^stage1;

^stage0:
  %stack[%sp] = %curr_n; %sp = %sp + %c1;
  %stack[%sp] = 1; %sp = %sp + %c1;
  %stack[%sp] = %s; %sp = %sp + %c1;
  %stack[%sp] = %d; %sp = %sp + %c1;
  %stack[%sp] = %a; %sp = %sp + %c1;

  %stack[%sp] = %curr_n - %c1; %sp = %sp + %c1;
  %stack[%sp] = 0; %sp = %sp + %c1;
  %stack[%sp] = %s; %sp = %sp + %c1;
  %stack[%sp] = %a; %sp = %sp + %c1;
  %stack[%sp] = %d; %sp = %sp + %c1;

  br ^while_loop;

^stage1:
  %moves = %moves + %c1;

  %stack[%sp] = %curr_n - %c1; %sp = %sp + %c1;
  %stack[%sp] = 0; %sp = %sp + %c1;
  %stack[%sp] = %a; %sp = %sp + %c1;
  %stack[%sp] = %d; %sp = %sp + %c1;
  %stack[%sp] = %s; %sp = %sp + %c1;

  br ^while_loop;

^exit:
  require %moves == 7, "Hanoi(3) should be 7 moves";
  ret %moves;
}
