// EXPECT: PASS
// Matrix Multiplication
// A: 2x3, B: 3x2, C: 2x2
// A = {{1,2,3}, {4,5,6}}
// B = {{7,8}, {9,1}, {2,3}}
// C = A*B = {{31,19}, {85,55}}

struct @Matrix { data: [2][3]i32; }
struct @Result { data: [2][2]i32; }

fun @main() : i32 {
  let mut %A: @Matrix;
  let mut %B: [3][2]i32;
  let mut %C: @Result = 0; // Initialize result matrix to 0
  let mut %i: i32 = 0;
  let mut %j: i32 = 0;
  let mut %k: i32 = 0;
  let mut %prod: i32 = 0;
  let mut %valA: i32 = 0;
  let mut %valB: i32 = 0;

^init:
  %A.data[0][0] = 1; %A.data[0][1] = 2; %A.data[0][2] = 3;
  %A.data[1][0] = 4; %A.data[1][1] = 5; %A.data[1][2] = 6;
  %B[0][0] = 7; %B[0][1] = 8;
  %B[1][0] = 9; %B[1][1] = 1;
  %B[2][0] = 2; %B[2][1] = 3;
  br ^outer_loop;

^outer_loop:
  %i = 0;
  br ^outer_cond;

^outer_cond:
  br %i < 2, ^mid_loop, ^verify;

^mid_loop:
  %j = 0;
  br ^mid_cond;

^mid_cond:
  br %j < 2, ^inner_loop_init, ^outer_inc;

^inner_loop_init:
  %C.data[%i][%j] = 0;
  %k = 0;
  br ^inner_cond;

^inner_cond:
  br %k < 3, ^inner_body, ^mid_inc;

^inner_body:
  %valA = %A.data[%i][%k];
  %valB = %B[%k][%j];
  %prod = %valA * %valB;
  %C.data[%i][%j] = %C.data[%i][%j] + %prod;
  %k = %k + 1;
  br ^inner_cond;

^mid_inc:
  %j = %j + 1;
  br ^mid_cond;

^outer_inc:
  %i = %i + 1;
  br ^outer_cond;

^verify:
  require %C.data[0][0] == 31;
  require %C.data[0][1] == 19;
  require %C.data[1][0] == 85;
  require %C.data[1][1] == 55;
  ret 0;
}
