// EXPECT: PASS
// Convex Hull (Jarvis March)
// Points: (0,0), (1,1), (2,2), (0,2), (2,0)
// Hull: (0,0), (2,0), (2,2), (0,2)

struct @Point { x: i32; y: i32; }
struct @HullResult { count: i32; indices: [10]i32; }

fun @main() : i32 {
  let mut %pts: [5]@Point;
  let mut %res: @HullResult = 0; // Init result
  let mut %i: i32 = 0;
  let mut %start: i32 = 0;
  let mut %sx: i32 = 0;
  let mut %ix: i32 = 0;
  let mut %curr: i32 = 0;
  let mut %next: i32 = 0;
  let mut %y_i: i32 = 0;
  let mut %y_curr: i32 = 0;
  let mut %x_next: i32 = 0;
  let mut %x_curr: i32 = 0;
  let mut %x_i: i32 = 0;
  let mut %y_next: i32 = 0;
  let mut %t1: i32 = 0;
  let mut %t2: i32 = 0;
  let mut %t3: i32 = 0;
  let mut %t4: i32 = 0;
  let mut %val: i32 = 0;
  let %five: i32 = 5;
  let mut %cnt: i32 = 0;

^init:
  %pts[0].x = 0; %pts[0].y = 0;
  %pts[1].x = 1; %pts[1].y = 1;
  %pts[2].x = 2; %pts[2].y = 2;
  %pts[3].x = 0; %pts[3].y = 2;
  %pts[4].x = 2; %pts[4].y = 0;
  %res.count = 0;
  br ^find_start_init;

^find_start_init:
  %start = 0;
  %i = 1;
  br ^find_start;

^find_start:
  br %i < 5, ^check_start, ^march_init;

^check_start:
  %sx = %pts[%start].x;
  %ix = %pts[%i].x;
  br %ix < %sx, ^update_start, ^find_start_inc;

^update_start:
  %start = %i;
  br ^find_start_inc;

^find_start_inc:
  %i = %i + 1;
  br ^find_start;

^march_init:
  %curr = %start;
  br ^march_loop;

^march_loop:
  %cnt = %res.count;
  %res.indices[%cnt] = %curr;
  %res.count = %cnt + 1;
  %next = %curr + 1;
  %next = %next % %five;
  %i = 0;
  br ^check_points;

^check_points:
  br %i < 5, ^cross_product, ^check_end;

^cross_product:
  %x_next = %pts[%next].x;
  %x_curr = %pts[%curr].x;
  %y_i = %pts[%i].y;
  %y_curr = %pts[%curr].y;
  %y_next = %pts[%next].y;
  %x_i = %pts[%i].x;

  // Cross product logic
  %t1 = %x_next - %x_curr;
  %t2 = %y_i - %y_curr;
  %t3 = %y_next - %y_curr;
  %t4 = %x_i - %x_curr;
  %val = %t1 * %t2 - %t3 * %t4;

  br %val > 0, ^update_next, ^check_points_inc;

^update_next:
  %next = %i;
  br ^check_points_inc;

^check_points_inc:
  %i = %i + 1;
  br ^check_points;

^check_end:
  %curr = %next;
  br %curr == %start, ^finish, ^march_loop;

^finish:
  require %res.count == 4;
  ret %res.count;
}
