// EXPECT: PASS
// Merge Sort (Iterative)
// Arr: {4, 3, 2, 1} -> {1, 2, 3, 4}

struct @Array { data: [4]i32; }
struct @SortParams { width: i32; size: i32; }

fun @main() : i32 {
  let mut %arr: @Array = { {4, 3, 2, 1} };
  let mut %temp: @Array = 0;
  let %params: @SortParams = { 1, 4 };
  let mut %width: i32 = 1;
  let mut %i: i32 = 0;
  let mut %left: i32 = 0;
  let mut %mid: i32 = 0;
  let mut %right: i32 = 0;
  let mut %l: i32 = 0;
  let mut %r: i32 = 0;
  let mut %k: i32 = 0;
  let mut %cond1: i32 = 0;
  let mut %cond2: i32 = 0;
  let mut %res_cond: i32 = 0;
  let mut %vl: i32 = 0;
  let mut %vr: i32 = 0;
  let mut %ci: i32 = 0;
  let %two: i32 = 2;

^outer_loop:
  br %width < 4, ^inner_loop_start, ^verify;

^inner_loop_start:
  %i = 0;
  br ^inner_loop_cond;

^inner_loop_cond:
  br %i < 4, ^merge_prep, ^outer_inc;

^merge_prep:
  %left = %i;
  %mid = %i + %width;
  %right = %i + %two * %width;
  %right = select %right < 4, %right, 4;
  %mid = select %mid < 4, %mid, 4;
  br %mid < %right, ^merge_start, ^inner_inc;

^merge_start:
  %l = %left;
  %r = %mid;
  %k = %left;
  br ^merge_cond;

^merge_cond:
  %cond1 = select %l < %mid, 1, 0;
  %cond2 = select %r < %right, 1, 0;
  %res_cond = %cond1 & %cond2;
  br %res_cond == 1, ^merge_cmp, ^merge_remain;

^merge_cmp:
  %vl = %arr.data[%l];
  %vr = %arr.data[%r];
  br %vl <= %vr, ^take_left, ^take_right;

^take_left:
  %temp.data[%k] = %vl;
  %l = %l + 1;
  %k = %k + 1;
  br ^merge_cond;

^take_right:
  %temp.data[%k] = %vr;
  %r = %r + 1;
  %k = %k + 1;
  br ^merge_cond;

^merge_remain:
  br %l < %mid, ^copy_left, ^check_right;

^copy_left:
  %temp.data[%k] = %arr.data[%l];
  %l = %l + 1;
  %k = %k + 1;
  br ^merge_remain;

^check_right:
  br %r < %right, ^copy_right, ^copy_back;

^copy_right:
  %temp.data[%k] = %arr.data[%r];
  %r = %r + 1;
  %k = %k + 1;
  br ^check_right;

^copy_back:
  %ci = %left;
  br ^copy_back_loop;

^copy_back_loop:
  br %ci < %right, ^copy_back_body, ^inner_inc;

^copy_back_body:
  %vl = %temp.data[%ci];
  %arr.data[%ci] = %vl;
  %ci = %ci + 1;
  br ^copy_back_loop;

^inner_inc:
  %i = %i + %two * %width;
  br ^inner_loop_cond;

^outer_inc:
  %width = %width * %two;
  br ^outer_loop;

^verify:
  require %arr.data[0] == 1, "arr[0] must be 1";
  require %arr.data[1] == 2, "arr[1] must be 2";
  require %arr.data[2] == 3, "arr[2] must be 3";
  require %arr.data[3] == 4, "arr[3] must be 4";
  ret 0;
}
